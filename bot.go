package bf

import (
	"context"
	"fmt"
	"sync"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

var _ ChatBot = &ChatBotImpl{}

type ChatBotImpl struct {
	tgbot               *tgbotapi.BotAPI
	chatHandlerLayers   map[int64]*HandlerLayer
	retryLayers         map[int64]*string
	defaultHandlerLayer *HandlerLayer
	layersMutex         sync.RWMutex
	retryLayersMutex    sync.RWMutex
	middlewares         []MiddlewareFunc
	errorHandler        ErrorHandlerFunc
	// TODO add opts
	debug bool
}

func (b *ChatBotImpl) GetFileURL(fileID string) (string, error) {
	url, err := b.tgbot.GetFileDirectURL(fileID)
	if err != nil {
		return "", errors.Wrap(err, "failed to get file direct url")
	}

	return url, nil
}

func (b *ChatBotImpl) LoaderButton(chatID int64, loadScreen []string) context.CancelFunc {
	loaderCtx, cancel := context.WithCancel(context.Background())

	go func() {
		msg := tgbotapi.NewMessage(chatID, loadScreen[0])

		sentMsg, err := b.tgbot.Send(msg)
		if err != nil {
			logrus.Errorf("failed to send loader message: %s", err)
		}

		ticker := time.NewTicker(loaderTickDelay * time.Millisecond)
		defer ticker.Stop()

		count := 0
		fullCount := 0

		for {
			select {
			case <-loaderCtx.Done():
				return
			case <-ticker.C:
				count++

				fullCount++
				if fullCount > 30 {
					msg := tgbotapi.NewEditMessageText(chatID, sentMsg.MessageID, "Timeout")
					if _, err := b.tgbot.Send(msg); err != nil {
						logrus.Errorf("failed to send loader message: %s", err)
					}

					return
				}

				count %= len(loadScreen)

				msg := tgbotapi.NewEditMessageText(chatID, sentMsg.MessageID, loadScreen[count])
				if _, err := b.tgbot.Send(msg); err != nil {
					logrus.Errorf("failed to send loader message: %s", err)
				}
			}
		}
	}()

	return cancel
}

func (b *ChatBotImpl) RegisterIButton(btn string, handler HandlerFunc) {
	b.defaultHandlerLayer.RegisterIButton(btn, handler)
}

func (b *ChatBotImpl) SelfUserName() string {
	return b.tgbot.Self.UserName
}

func (b *ChatBotImpl) RegisterButton(btn string, handler HandlerFunc) {
	b.defaultHandlerLayer.RegisterButton(btn, handler)
}

func (b *ChatBotImpl) RegisterAudio(handler HandlerFunc) {
	b.defaultHandlerLayer.RegisterVoice(handler)
}

func (b *ChatBotImpl) SendText(chatID int64, text string) error {
	logrus.Debugf("sending text to chat %d: %s", chatID, text)

	layer := b.NewLayer()
	layer.AddText(text)

	_, err := b.tgbot.Send(tgbotapi.NewMessage(chatID, layer.text))

	return errors.Wrap(err, "failed to send text")
}

// NewLayer creates new layer. Layer is a set of handlers for different types of events.
// msgText - text that will be sent to user when layer is activated via `SendMsg` method.
func (b *ChatBotImpl) NewLayer(msgText ...any) *HandlerLayer {
	logrus.Debugf("creating new layer")

	return &HandlerLayer{
		text:                fmt.Sprintln(msgText...),
		commandHandler:      make(map[string]CommandHandler),
		textHandler:         make(map[string]TextHandler),
		buttonHandler:       make(map[string]InlineButtonHandler),
		audioHandler:        nil,
		layerDefaultHandler: nil,
		ttl:                 time.Now().Add(time.Hour * 24),
		generalMiddlewares:  b.middlewares,
		rowMode:             false,
	}
}

// NewBot creates new bot instance.
// apikey - telegram bot api key generated by BotFather.
func NewBot(apikey string) (*ChatBotImpl, error) {
	logrus.Debugf("creating new bot")

	bot, err := tgbotapi.NewBotAPI(apikey)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create bot")
	}

	botBuilderInstance := &ChatBotImpl{
		tgbot:               bot,
		chatHandlerLayers:   make(map[int64]*HandlerLayer),
		retryLayers:         map[int64]*string{},
		defaultHandlerLayer: nil,
		layersMutex:         sync.RWMutex{},
		retryLayersMutex:    sync.RWMutex{},
		middlewares:         make([]MiddlewareFunc, 0),
		errorHandler:        nil,
		// TODO add debug option
		debug: false,
	}
	botBuilderInstance.defaultHandlerLayer = botBuilderInstance.NewLayer()
	botBuilderInstance.defaultHandlerLayer.ttl = time.Now().Add(time.Hour * 24 * 365 * 100) // we don't want to expire it
	botBuilderInstance.RegisterErrorHandler(botBuilderInstance.defaultErrorHandler)
	botBuilderInstance.RegisterDefaultHandler(botBuilderInstance.defaultEventHandler)

	go botBuilderInstance.cleaner()

	return botBuilderInstance, nil
}

func (b *ChatBotImpl) Start(ctx context.Context) error {
	logrus.Debugf("starting bot")

	err := b.validateConfiguration()
	if err != nil {
		return errors.Wrap(err, "failed to validate configuration")
	}

	updates := b.tgbot.GetUpdatesChan(tgbotapi.UpdateConfig{
		Timeout: 60,
	})

	return b.mainLoop(ctx, updates)
}

func (b *ChatBotImpl) mainLoop(ctx context.Context, updates tgbotapi.UpdatesChannel) error {
	for update := range updates {
		go func(update tgbotapi.Update) {
			event, ok := newEvent(update)
			if !ok {
				b.errorHandler(ctx, event, ErrUnparsedEvent)
				return
			}

			logrus.Debugf("got event: %#v", event)
			layer := b.findAndWipeChatLayerHandler(event.ChatID)
			event.lastLayer = layer
			handlerFunc := b.availableHandlerFromLayers(event, layer, b.defaultHandlerLayer)

			err := b.applyMiddlewares(handlerFunc)(ctx, event)
			if err != nil {
				b.errorHandler(ctx, event, err)
			}
		}(update)
	}

	return nil
}

func (b *ChatBotImpl) setLayer(layer *HandlerLayer, chatID int64) {
	b.layersMutex.Lock()
	b.chatHandlerLayers[chatID] = layer
	b.layersMutex.Unlock()
}

func (b *ChatBotImpl) applyMiddlewares(handlerFunc HandlerFunc) HandlerFunc {
	for _, middleware := range b.middlewares {
		handlerFunc = middleware(handlerFunc)
	}

	return handlerFunc
}

func (b *ChatBotImpl) availableHandlerFromLayers(event Event, chatLayer, defaultLayer *HandlerLayer) HandlerFunc {
	handlerFunc := chatLayer.Handler(event)
	if handlerFunc == nil {
		handlerFunc = defaultLayer.Handler(event)
	}

	return handlerFunc
}

func (b *ChatBotImpl) SendMsg(chatID int64, layer *HandlerLayer) error {
	message := tgbotapi.NewMessage(chatID, layer.text)
	sortedIButtonsSlice := layer.sortedIButtonsSlice()
	rawIButtons := make([]tgbotapi.InlineKeyboardButton, 0, len(sortedIButtonsSlice))

	var rawButtons []tgbotapi.KeyboardButton

	for _, button := range sortedIButtonsSlice {
		rawIButtons = append(rawIButtons, button.button)
	}

	for _, button := range layer.textHandler {
		if button.kind == TextHandlerKindButton {
			rawButtons = append(rawButtons, tgbotapi.NewKeyboardButton(button.text))
		}
	}

	isInline := len(rawIButtons) > 0
	if isInline {
		message.ReplyMarkup = b.buildInlineKeyboard(rawIButtons, layer.rowMode)
	}

	isRegular := len(rawButtons) > 0
	if isRegular {
		message.ReplyMarkup = tgbotapi.NewReplyKeyboard(rawButtons)
	}

	if isInline && isRegular {
		return errors.New("can't send both inline and regular buttons")
	}

	b.setLayer(layer, chatID)

	message.ParseMode = tgbotapi.ModeHTML

	_, err := b.tgbot.Send(message)

	return errors.Wrap(err, "failed to send message")
}

func (b *ChatBotImpl) buildInlineKeyboard(
	rawIButtons []tgbotapi.InlineKeyboardButton,
	rowMode bool,
) tgbotapi.InlineKeyboardMarkup {
	if rowMode {
		return tgbotapi.InlineKeyboardMarkup{
			InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{
				rawIButtons[:len(rawIButtons)-1],
				{rawIButtons[len(rawIButtons)-1]},
			},
		}
	}

	iButtons := make([][]tgbotapi.InlineKeyboardButton, 0, len(rawIButtons))
	for _, button := range rawIButtons {
		iButtons = append(iButtons, []tgbotapi.InlineKeyboardButton{button})
	}

	return tgbotapi.InlineKeyboardMarkup{InlineKeyboard: iButtons}
}

func (b *ChatBotImpl) RetryLastLayer(event Event, newText string) error {
	previousLayer := event.lastLayer

	if previousLayer == nil {
		return errors.Errorf("RetryLastLayer: no previous layer for chat %d", event.ChatID)
	}

	if newText != "" {
		previousLayer.text = newText
	}

	return b.SendMsg(event.ChatID, previousLayer)
}

func (b *ChatBotImpl) RegisterCommand(command string, handler HandlerFunc) {
	b.defaultHandlerLayer.RegisterCommand(command, handler)
}

func (b *ChatBotImpl) RegisterErrorHandler(handler ErrorHandlerFunc) {
	b.errorHandler = handler
}

func (b *ChatBotImpl) RegisterMiddleware(middleware MiddlewareFunc) {
	b.middlewares = append(b.middlewares, middleware)
}

func (b *ChatBotImpl) findAndWipeChatLayerHandler(chatID int64) *HandlerLayer {
	layer, ok := b.getLayer(chatID)

	if !ok {
		return b.defaultHandlerLayer
	}

	if ok {
		b.deleteLayer(chatID)
	}

	return layer
}

func (b *ChatBotImpl) deleteLayer(chatID int64) {
	b.layersMutex.Lock()
	delete(b.chatHandlerLayers, chatID)
	b.layersMutex.Unlock()
}

func (b *ChatBotImpl) getLayer(chatID int64) (*HandlerLayer, bool) {
	b.layersMutex.RLock()
	defer b.layersMutex.RUnlock()

	layer, ok := b.chatHandlerLayers[chatID]

	return layer, ok
}

func (b *ChatBotImpl) cleaner() {
	for {
		time.Sleep(10 * time.Minute)
		b.layersMutex.Lock()
		for chatID, layer := range b.chatHandlerLayers {
			if layer.IsExpired() {
				delete(b.chatHandlerLayers, chatID)
			}
		}
		b.layersMutex.Unlock()
	}
}

func (b *ChatBotImpl) RegisterDefaultHandler(handler HandlerFunc) {
	b.defaultHandlerLayer.layerDefaultHandler = handler
}

func (b *ChatBotImpl) validateConfiguration() error {
	if b.errorHandler == nil {
		return errors.New("error handler is not set")
	}

	if b.defaultHandlerLayer == nil {
		return errors.New("default handler layer is not set")
	}

	if b.defaultHandlerLayer.layerDefaultHandler == nil {
		return errors.New("default handler is not set")
	}

	return nil
}
